<p>A <strong>recursive property</strong> refers to itself in its own consequent, creating a self-referential temporal statement that unrolls indefinitely:</p>
<pre>property p_lock_hold;
  @(posedge clk) lock && !unlock |=> p_lock_hold;
endproperty</pre>
<p>This reads: "if <code>lock</code> is high and <code>unlock</code> has not fired, one cycle later the same condition must hold again — forever, until <code>unlock</code> fires." Recursive properties must use <code>|=&gt;</code> (never <code>|-&gt;</code>) to avoid a zero-time loop, and the recursive call must appear as the <em>consequent</em>, never the antecedent.</p>
<p>The WASM tool does not yet support recursive property calls. This exercise uses the equivalent one-step form that BMC can verify directly:</p>
<pre>lock && !unlock |=> lock</pre>
<p>This says "if <code>lock</code> is high and <code>unlock</code> has not fired, <code>lock</code> must be high on the next cycle." BMC checks this for every cycle up to its bound — which is equivalent to the recursive version within any finite trace. Open <code>lock_check.sv</code> and complete the property.</p>
<blockquote><p>Full formal tools prove recursive properties by induction: they show (a) the property holds at step 0, and (b) if it holds at step k, it holds at step k+1. This gives an unbounded proof without requiring an unbounded bound.</p></blockquote>
