            <p><strong>Logical Equivalence Checking (LEC)</strong> proves that two circuit implementations produce identical outputs for every possible input — without running any simulation.</p>
            <p>Open <code>top.sv</code>. It contains two modules:</p>
            <ul>
              <li><code>Spec</code> — the golden reference: a NAND gate <code>~(a &amp; b)</code></li>
              <li><code>Impl</code> — your implementation, currently wrong</li>
            </ul>
            <p>By <strong>De Morgan's law</strong>, <code>~(a &amp; b)</code> is logically equivalent to <code>~a | ~b</code>. The <code>Impl</code> module has a bug — it is missing the inversion on <code>b</code>. Fix it:</p>
            <pre>assign y = ~a | ~b;</pre>
            <p>Click <strong>verify</strong> to run LEC on the buggy code first. The tool encodes both modules as SMT constraints and asks a solver whether any input can make them differ. Because the bug is real, the solver finds one — it reports <strong>sat</strong> and shows a counterexample:</p>
            <pre># counterexample: a=1 b=1</pre>
            <p>You can verify this by hand: with <code>a=1, b=1</code>, Spec produces <code>~(1 &amp; 1) = 0</code> while the buggy Impl produces <code>~1 | 1 = 1</code> — they disagree.</p>
            <p>Fix the bug, then click <strong>verify</strong> again. With no distinguishing input, the solver reports <strong>unsat</strong> — the circuits are equivalent for every possible input.</p>
            <blockquote><p>LEC is essential in chip design: it proves that logic synthesis, optimisation, and place-and-route have not changed the circuit's behaviour.</p></blockquote>
