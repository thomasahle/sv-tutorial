              <svg width="380" height="130" viewBox="0 0 380 130" xmlns="http://www.w3.org/2000/svg" style="display:block;max-width:100%;font-family:'IBM Plex Mono',monospace;font-size:12px;margin:10px auto">
  <defs>
    <marker id="fsm-a" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
      <path d="M0,0 L8,3 L0,6 Z" fill="#586469"/>
    </marker>
  </defs>
  <!-- always_comb box -->
  <rect x="55" y="20" width="155" height="75" rx="4" fill="#e6f5f5" stroke="#0d6f72" stroke-width="1.5"/>
  <text x="132" y="48" text-anchor="middle" font-weight="bold" fill="#0a5558">Comb. Logic</text>
  <text x="132" y="65" text-anchor="middle" fill="#3d9fa3" font-size="11">always_comb</text>
  <text x="132" y="83" text-anchor="middle" fill="#586469" font-size="10">next_state + outputs</text>
  <!-- always_ff box -->
  <rect x="240" y="30" width="130" height="55" rx="4" fill="#fff7ee" stroke="#cc5f2d" stroke-width="1.5"/>
  <text x="305" y="55" text-anchor="middle" font-weight="bold" fill="#9a3a15">State Reg</text>
  <text x="305" y="72" text-anchor="middle" fill="#cc5f2d" font-size="11">always_ff</text>
  <!-- next_state arrow (top) -->
  <line x1="210" y1="43" x2="238" y2="43" stroke="#586469" stroke-width="1.5" marker-end="url(#fsm-a)"/>
  <text x="224" y="37" text-anchor="middle" fill="#586469" font-size="10">next_state</text>
  <!-- state feedback arrow (bottom) -->
  <line x1="240" y1="72" x2="212" y2="72" stroke="#586469" stroke-width="1.5" marker-end="url(#fsm-a)"/>
  <text x="226" y="86" text-anchor="middle" fill="#586469" font-size="10">state</text>
  <!-- inputs arrow -->
  <line x1="8" y1="57" x2="53" y2="57" stroke="#586469" stroke-width="1.5" marker-end="url(#fsm-a)"/>
  <text x="30" y="51" text-anchor="middle" fill="#586469">inputs</text>
  <!-- outputs arrow -->
  <line x1="132" y1="95" x2="132" y2="122" stroke="#586469" stroke-width="1.5" marker-end="url(#fsm-a)"/>
  <text x="155" y="119" fill="#586469">outputs</text>
</svg>
<p>A <strong><dfn data-card="A Moore FSM (Finite State Machine) is one where the outputs depend only on the current state, not on the current inputs. This makes outputs glitch-free and registered. Contrast with a Mealy FSM where outputs depend on both state and inputs (faster response, one cycle earlier, but outputs can glitch mid-cycle). Moore FSMs are preferred in synchronous RTL because output timing is predictable.">Moore FSM</dfn></strong> separates state memory from output computation into two <code>always</code> blocks. The <strong>memory access controller</strong> decides when and how the SRAM gets written or read:</p>
              <ul>
                <li><strong>IDLE</strong> — waiting for a command; assert <code>ready=1</code>. On the next cycle, transition to WRITING if <code>cmd_valid &amp;&amp; cmd_we</code>, to READING if <code>cmd_valid &amp;&amp; !cmd_we</code>, otherwise stay in IDLE.</li>
                <li><strong>READING</strong> — assert <code>sram_we=0</code> and return to IDLE next cycle</li>
                <li><strong>WRITING</strong> — assert <code>sram_we=1</code> and return to IDLE next cycle</li>
              </ul>
              <p>Open <code>mem_ctrl.sv</code>. The two-always skeleton and default assignments are already set up. Fill in the <code>case</code> branches inside <code>always_comb</code>: the transition conditions in <code>IDLE</code>, and the output + transition for <code>READING</code> and <code>WRITING</code>.</p>
              <blockquote><p>Keep outputs in the <code>always_comb</code> block, never in the <code>always_ff</code> block — Moore outputs are a function of state only, not of the current inputs. A <strong>Mealy FSM</strong> would also allow outputs to depend directly on inputs, giving a one-cycle faster response — but at the cost of glitchy combinational outputs that change mid-cycle whenever inputs change. Moore is the safer default for synchronous RTL.</p></blockquote>
              <h2>Testbench</h2>
              <p>The testbench cycles through all three states — idle, write command, read command — and checks that <code>sram_we</code> and <code>ready</code> assert at the right times.</p>
