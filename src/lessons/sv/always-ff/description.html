              <p><code>always_ff</code> models edge-triggered sequential logic. Unlike <code>always_comb</code>, it only updates when a clock edge occurs.</p>
              <p>Use <strong>non-blocking assignment</strong> (<code>&lt;=</code>) inside <code>always_ff</code>. All right-hand sides are evaluated first, then all assignments happen simultaneously at the clock edge — this prevents race conditions.</p>
              <p>Open <code>dff.sv</code> and implement the flip-flop body:</p>
              <pre>always_ff @(posedge clk) begin
  if (!rst_n) q &lt;= 1'b0;
  else        q &lt;= d;
end</pre>
              <blockquote><p>Active-low reset (<code>rst_n</code>) is conventional in RTL: the signal name ends in <code>_n</code> and asserts at 0.</p></blockquote>
              <h2>Testbench</h2>
              <p>The clock is generated with a free-running toggle: <code>always #5 clk = ~clk;</code> (period = 10 time units). The testbench uses <code>@(posedge clk); #1;</code> to wait for a rising edge and then sample outputs one unit later — after the flip-flop has settled but before the next edge.</p>
              <p>The three test steps check reset, clocking in a 1, and clocking in a 0. Open the <strong>Waves</strong> tab after running to see <code>clk</code>, <code>rst_n</code>, <code>d</code>, and <code>q</code> plotted over time — <code>q</code> should follow <code>d</code> exactly one cycle after reset is released.</p>
